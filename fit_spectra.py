#!/usr/bin/env python
"""
This fits SpFrame spectra with airglow lines and a simple model for the continuum, 
including zodiacal light. The fit is done using a simple linear regression. 
After running the least squares fit, the fitted lines are separated from the continuum and 
the lines, continuum and residuals are returned independently.

INPUT: * SpFrame flux files as .npy files with wavelength and sky spectra 
       * Also need a list of airglow lines. these should be on the github repo

OUTPUT: numpy files identified in the same way as the sky_flux files with the plate number 
and file identifier "split_spectra". The numpy arrays have the following fields: WAVE, LINES, CONT, RESIDS

Before running, identify the directory that the spframe flux files are kept and where the airglow lines are
saved. Also identify where you want to save the files generated by this program (SAVE_DIR)

Title: SpFrame Flux Spectra Fit
Author: P. Fagrelius
Date: May 24, 2017

"""
import glob 
import os
import multiprocessing
import numpy as np
import pandas as pd
import statsmodels.api as sm
from scipy.special import eval_legendre

parallel = True
MPI = False

#Directory to save data
SAVE_DIR = '/Volumes/PARKER/boss_files/split_spectra/'
#Directory where all SpFrame flux files reside
SPECTRA_DIR = '/Volumes/PARKER/boss_files/new_sky_flux/'
AIRGLOW_DIR = '/Users/parkerf/Research/SkyModel/SkyModelling/AirglowSpectra/cosby/'
def main():
    # Load spectra data

    SAVED_FILES = glob.glob(SAVE_DIR+"*_split_fit.npy")
    SPECTRA_FILES = glob.glob(SPECTRA_DIR+"*_calibrated_sky.npy")
    SPECTRA = get_plates_needed(SAVED_FILES, SPECTRA_FILES)
    print(SPECTRA)
    global MetaData
    MetaData = np.load(SPECTRA_DIR+'meta_raw.npy')
    print("got MetaData")

    #Identify which data you want to look at
    #Options: test (10 total), blue, red, full
    global ttype
    ttype = 'full'
    
    if parallel:
        pool = multiprocessing.Pool(processes=4)
        data = pool.map(fit_and_separate_spectra, SPECTRA)
        pool.terminate()
    else:
        data = [fit_and_separate_spectra(p) for p in SPECTRA]
    
def get_plates_needed(saved_files, total_files):
    """This function compares what spectra have already been split so that if program
    stops working in the middle you don't have to start over"""

    Complete = [d[-18:-14] for d in saved_files]
    print(Complete)
    Total = [d[-23:-19] for d in total_files]
    print(Total)
    Needed_idx = [i for i, x in enumerate(Total) if x not in Complete]
    print(Needed_idx)
    SPECTRA = [total_files[x] for x in Needed_idx]
    print('Will be analyzing %d plate files' % len(Needed_idx))
    return SPECTRA

def get_airglow_spectra():
    """This function loads the airglow files from Cosby et al paper and changes the format"""

    AF = glob.glob(AIRGLOW_DIR+'/*.txt')
    AL = []
    for file in AF:
        data = pd.read_csv(file, delim_whitespace=True)
        d = data.to_records(index=False)
        AL.append(np.array(d))
    AirglowLines = np.hstack(AL)
    return AirglowLines

def get_vac_lines(AirglowLines):
    """Gets only the airglow lines needed to make an appropriate fit. This is different for
    the blue and red CCDs. """
    b_sig = np.where(AirglowLines['obs_eint'] > 5)
    bVL = air_to_vac(AirglowLines['obs_wave'])
    bVL = bVL[b_sig] #nm to A
    BlueVacLines = bVL[bVL < 700]

    r_sig = np.where(AirglowLines['obs_eint'] > 5)
    rVL = air_to_vac(AirglowLines['obs_wave'])
    rVL = rVL[r_sig] #nm to A
    RedVacLines = rVL[rVL > 560]

    return BlueVacLines, RedVacLines


def clean_spectra(spectrum):
    """Takes out all nan/inf so lstsq will run smoothly
    """
    ok = np.isfinite(spectrum['SKY'])

    wave = spectrum['WAVE'][ok]
    sky = spectrum['SKY'][ok]
    sigma = spectrum['SIGMA'][ok]
    disp = spectrum['DISP'][ok]
    
    return [wave,sky,sigma,disp]

def air_to_vac(wave):
    """Index of refraction to go from wavelength in air to wavelength in vacuum
    Equation from (Edlen 1966)
    vac_wave = n*air_wave
    """
    #Convert to um
    wave_um = wave*.001
    ohm2 = (1./wave_um)**(2)

    #Calculate index at every wavelength
    nn = []
    for x in ohm2:
        n = 1+10**(-8)*(8342.13 + (2406030/float(130.-x)) + (15997/float(389-x)))
        nn.append(n)
    
    #Get new wavelength by multiplying by index of refraction
    vac_wave = nn*wave
    return vac_wave

def airglow_line_components(airglow_lines, wave_range, disp_range):
    """ Takes each Airglow line included in the analysis and creates a gaussian profile 
    of the line. 
    INPUT: - List of airglow lines wanted to model
           - Wavelength range of the spectra
           - Sigma for the wavelength range of the spectra
    OUTPUT: 
           Matrix with all lines used for lienar regression. Size[len(wave_range),len(airglow_lines)]
    """
    AA = []
    for line in airglow_lines:
        ss = []
        for i, w in enumerate(wave_range):
            sig = disp_range[i]
            ss.append(np.exp(-0.5*((w-line)/sig)**2))
        AA.append(ss)
    return np.vstack(AA)


def linear_model(spectrum, num_cont, airglow_lines):
        """ This is the heart of the program. It computes the linear model using Ordinary Least Squares. It then
        splits up the model into components: lines, continuum and residuals.
        The inputs characterize whether it is a blue or red sky fit. They have slightly different 
        continuum models and we break up the airglow lines so that it is faster.

        INPUTS:  - sky spectrum: from Boss Sky Spectra (generated by spframe_flux.py)
                 - num_cont: the number of polynomials used for the continuum fitting
                 - airglow_lines: the set of lines used to fit out the airglow. different for blue/red
        OUTPUTS: - wave_range: original wavelength range (generated by spframe_flux.py)
                 - lines: Airglow lines fitted
                 - cont: Continuum fitted
                 - res: Residuals between linear model and original sky flux
                 - R: R^2 value to determine goodness of fit
        """

        wave_range, sky_spectra, sigma_range, disp_range = clean_spectra(spectrum)

        AA = airglow_line_components(airglow_lines, wave_range, disp_range)

        # Continuum model
        AC = []
        for i in range(num_cont):
            AC.append(eval_legendre(i, wave_range))
        AC = np.array(AC)
        A = np.stack(np.vstack((AC, AA)), axis=1)

        results = sm.OLS(sky_spectra, A).fit()
        params = results.params
        model = np.dot(A, params)

        #Separate
        cont = np.dot(A[:,0:num_cont], params[0:num_cont])
        lines = np.dot(A[:,num_cont:], params[num_cont:])
        res = sky_spectra - model
        
        #R^2
        R_1 = np.sum([(i)**2 for i in res])
        R_2 = np.sum([(i-np.mean(sky_spectra))**2 for i in sky_spectra])  
        R = 1-(R_1/R_2)   

        return [wave_range, lines, cont, res, R]

def fit_and_separate_spectra(spectra_file):
        """Function that runs the linear model and saves the output. The output file is a .npy file that includes
        the parts of the model (lines, continuum, and residuals) along with the wavelengths associated for ease in comparison.
        It also contains some meta data so that these linear models can be correlated with the actual flux.

        This funciton is used in a multiprocessing loop.
        """

        BlueVacLines, RedVacLines = get_vac_lines(get_airglow_spectra())

        plate_num = spectra_file[-23:-19]
        print("Fitting spectra in plate %s" % plate_num)
        spectra = np.load(spectra_file)
        this_plate = MetaData[MetaData['PLATE'] == int(plate_num)]

        if ttype == 'test':
            max_num = 10 
            specnos = this_plate[0: max_num]['SPECNO']
        elif ttype == 'blue':
            max_num = len(spectra)-1
            specnos = this_plate[(this_plate['CAMERAS'] == b'b1') | (this_plate['CAMERAS'] == b'b2')]['SPECNO']
        elif ttype == 'red':
            max_num = len(spectra)-1
            specnos = this_plate[(this_plate['CAMERAS'] == b'r1') | (this_plate['CAMERAS'] == b'r2')]['SPECNO']
        elif ttype == 'full':
            max_num = len(spectra)
            specnos = this_plate['SPECNO']
        else: 
            print("not a valid type. Going to test")
            max_num = 10 #len(spectra) Number of spectra in a given plate that you want to run this for. Mostly for debugging
            specnos = np.random.choice(this_plate['SPECNO'], size=max_num)

        num = 0
        data = []
        for i, specno in enumerate(specnos):
            if num < max_num:
                print('splitting spectra %d/%d for plate %s' % (i, len(specnos), plate_num))
                this_obs = this_plate[this_plate['SPECNO'] == specno]
                if len(this_obs) > 1:
                    this_obs = this_obs[0]
                    print("This observation had more than one specno with that number")
                else:
                    pass
                if (this_obs['CAMERAS'] == b'b1') | (this_obs['CAMERAS'] == b'b2'):
                    model = linear_model(spectra[specno], 3, BlueVacLines)
                elif (this_obs['CAMERAS'] == b'r1') | (this_obs['CAMERAS'] == b'r2'):
                    model = linear_model(spectra[specno], 2, RedVacLines)
                else:
                    print("Don't recognize the camera")
                    model = [0, 0, 0, 0, 0]
               
                model_fit = np.zeros(len(model[0]),dtype=[('PLATE','i4'), ('COLOR','S2'), ('SPECNO','i4'), ('WAVE','f8'), ('LINES','f8'), ('CONT','f8'), ('RESIDS','f8'), ('R','f8')])
                model_fit['PLATE'] = plate_num
                model_fit['COLOR'] = this_obs['CAMERAS']
                model_fit['SPECNO'] = specno
                model_fit['WAVE'] = model[0]
                model_fit['LINES'] = model[1]
                model_fit['CONT'] = model[2]
                model_fit['RESIDS'] = model[3]
                model_fit['R'] = model[4]
                data.append(model_fit)
                num+=1
            else:
                break

        np.save(SAVE_DIR+plate_num+'_split_fit',data)

        

if __name__=="__main__":
          main()


